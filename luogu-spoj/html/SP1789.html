<!DOCTYPE html>
<html class="no-js" lang="zh">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>GREEDULM - Huffman´s Greed - 洛谷</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="renderer" content="webkit">
<meta name="csrf-token" content="1573449682:ouxpXRNnDi+WB2Guv88azl9dRYz9HbdWRksuBN6dUKc=">
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" media="screen"/>
<link rel="stylesheet" href="https://cdn.luogu.com.cn/fe/loader.css?ver=20191106">
<script>window._feInjection = JSON.parse(decodeURIComponent("%7B%22code%22%3A200%2C%22currentTemplate%22%3A%22ProblemShow%22%2C%22currentData%22%3A%7B%22problem%22%3A%7B%22background%22%3Anull%2C%22description%22%3A%22%20In%20the%20following%20we%20define%20the%20basic%20terminology%20of%20trees.%20A%20%2A%2Atree%2A%2A%20is%20defined%20inductively%3A%20It%20has%20a%20%2A%2Aroot%2A%2A%20which%20is%20either%20an%20%2A%2Aexternal%20node%2A%2A%20%28a%20leaf%29%2C%20or%20an%20%2A%2Ainternal%20node%2A%2A%20having%20a%20sequence%20of%20trees%20as%20its%20children.%20An%20internal%20node%20is%20also%20called%20the%20%2A%2Aparent%2A%2A%20of%20the%20roots%20of%20its%20child%20trees.%20The%20%2A%2Alevel%2A%2A%20of%20a%20node%20in%20a%20tree%20is%20defined%20inductively%3A%20The%20root%20has%20level%20%600%60%2C%20and%20the%20level%20of%20a%20node%20is%20%601%60%20more%20than%20the%20level%20of%20its%20parent%20node.%5Cn%5Cn%20Every%20internal%20node%20of%20a%20%2A%2Abinary%20tree%2A%2A%20has%20precisely%20two%20children%2C%20its%20left%20sub-tree%20and%20its%20right%20sub-tree.%20Every%20internal%20node%20of%20a%20%2A%2Alabelled%20binary%20tree%2A%2A%20is%20additionally%20marked%20with%20a%20string%2C%20its%20label.%20A%20%2A%2Abinary%20search%20tree%2A%2A%20is%20a%20labelled%20binary%20tree%20where%20every%20internal%20node%20%60t%60%20satisfies%20the%20following%20condition%3A%20All%20labels%20of%20nodes%20in%20the%20left%20sub-tree%20of%20%60t%60%20are%20less%20than%20the%20label%20of%20%60t%60%20which%20is%2C%20in%20turn%2C%20less%20than%20all%20labels%20of%20nodes%20in%20the%20right%20sub-tree%20of%20%60t%60.%20For%20this%20condition%2C%20we%20assume%20lexicographic%2C%20i.e.%2C%20alphabetic%20order%20on%20the%20strings.%5Cn%5Cn%20An%20%2A%2Ainorder%20traversal%2A%2A%20of%20a%20tree%20is%20defined%20recursively%3A%20A%20leaf%20is%20just%20visited%2C%20and%20for%20an%20internal%20node%20first%20its%20left%20sub-tree%20is%20traversed%20inorder%2C%20then%20the%20node%20itself%20is%20visited%2C%20finally%20its%20right%20sub-tree%20is%20traversed%20inorder.%20It%20follows%20that%20an%20inorder%20traversal%20of%20a%20binary%20search%20tree%20yields%20the%20labels%20in%20lexicographic%20order.%20Note%20that%20binary%20search%20trees%20whose%20shapes%20differ%20may%20nevertheless%20yield%20the%20same%20sequence%20of%20strings%20while%20being%20traversed%20inorder.%5Cn%5Cn%20When%20a%20given%20string%20%60s%60%20is%20looked%20for%20in%20a%20binary%20search%20tree%2C%20we%20compare%20%60s%60%20to%20the%20label%20%60l%60%20of%20the%20root.%20We%20are%20done%20if%20%60s%3Dl%60%2C%20otherwise%20if%20%60s%3Cl%60%20we%20continue%20to%20search%20in%20the%20left%20sub-tree%2C%20and%20if%20%60s%3El%60%20in%20the%20right%20sub-tree.%20If%20a%20leaf%20is%20reached%2C%20we%20know%20that%20%60s%60%20is%20not%20in%20the%20tree.%5Cn%5Cn%20The%20number%20of%20comparisons%20performed%20in%20such%20a%20search%20procedure%20depends%20on%20%60s%60%20and%20the%20actual%20shape%20of%20the%20search%20tree.%20Therefore%2C%20there%20is%20an%20interest%20in%20constructing%20binary%20search%20trees%20that%20store%20a%20given%20sequence%20of%20strings%20but%20provide%20as%20efficient%20access%20as%20possible.%20Of%20course%2C%20we%20don%27t%20know%20in%20advance%20which%20strings%20will%20be%20looked%20up%20in%20the%20tree%2C%20so%20we%20need%20to%20make%20some%20assumptions.%5Cn%5Cn%20Let%20%60n%60%20be%20the%20number%20of%20strings%20that%20are%20to%20be%20stored%20in%20the%20binary%20search%20tree.%20Let%20%60K%20%24%20_%7B1%7D%20%24%20%2C...%2CK%20%24%20_%7Bn%7D%20%24%20%60%20be%20these%20strings%20in%20lexicographic%20order.%20Let%20%60p%20%24%20_%7B1%7D%20%24%20%2C...%2Cp%20%24%20_%7Bn%7D%20%24%20%60%20and%20%60q%20%24%20_%7B0%7D%20%24%20%2C...%2Cq%20%24%20_%7Bn%7D%20%24%20%60%20be%20%602n%2B1%60%20non-negative%20real%20numbers%20such%20that%20%60%5Cu2211%20%24%20_%7Bi%3D1..n%7D%20%24%20%20p%20%24%20_%7Bi%7D%20%24%20%20%2B%20%5Cu2211%20%24%20_%7Bi%3D0..n%7D%20%24%20%20q%20%24%20_%7Bi%7D%20%24%20%20%3D%201%60.%20The%20interpretation%20of%20these%20numbers%20is%3A%5Cn%5Cn-%20%60p%20%24%20_%7Bi%7D%20%24%20%60%20%3D%20probability%20that%20the%20search%20argument%20%60s%60%20is%20%60K%20%24%20_%7Bi%7D%20%24%20%60.%5Cn-%20%60q%20%24%20_%7Bi%7D%20%24%20%60%20%3D%20probability%20that%20%60s%60%20lies%20%28lexicographically%29%20strictly%20between%20%60K%20%24%20_%7Bi%7D%20%24%20%60%20and%20%60K%20%24%20_%7Bi%2B1%7D%20%24%20%60.%5Cn%5Cn%20By%20convention%2C%20%60q%20%24%20_%7B0%7D%20%24%20%60%20is%20the%20probability%20that%20%60s%60%20is%20less%20than%20%60K%20%24%20_%7B1%7D%20%24%20%60%2C%20and%20%60q%20%24%20_%7Bn%7D%20%24%20%60%20is%20the%20probability%20that%20%60s%60%20is%20greater%20than%20%60K%20%24%20_%7Bn%7D%20%24%20%60.%20We%20want%20to%20find%20a%20binary%20search%20tree%20containing%20nodes%20with%20labels%20%60K%20%24%20_%7B1%7D%20%24%20%2C...%2CK%20%24%20_%7Bn%7D%20%24%20%60%20that%20minimises%20the%20expected%20number%20of%20comparisons%20in%20the%20search%2C%20namely%5Cn%5Cn%60cost%20%3D%20%5Cu2211%20%24%20_%7Bi%3D1..n%7D%20%24%20%20p%20%24%20_%7Bi%7D%20%24%20%2A%281%20%2B%20level%20of%20internal%20node%20K%20%24%20_%7Bi%7D%20%24%20%29%20%2B%20%5Cu2211%20%24%20_%7Bi%3D0..n%7D%20%24%20%20q%20%24%20_%7Bi%7D%20%24%20%2A%28level%20of%20leaf%20between%20K%20%24%20_%7Bi%7D%20%24%20%20and%20K%20%24%20_%7Bi%2B1%7D%20%24%20%29%60.%20%20The%20leaf%20between%20%60K%20%24%20_%7Bi%7D%20%24%20%60%20and%20%60K%20%24%20_%7Bi%2B1%7D%20%24%20%60%20is%20that%20leaf%20reached%20in%20the%20search%20for%20a%20string%20%60s%60%20that%20lies%20%28lexicographically%29%20strictly%20between%20%60K%20%24%20_%7Bi%7D%20%24%20%60%20and%20%60K%20%24%20_%7Bi%2B1%7D%20%24%20%60.%20Adhere%20to%20the%20convention%20stated%20above%20for%20the%20border%20cases.%5Cn%5Cn%20The%20following%20figure%20illustrates%20the%20first%20test%20case%20of%20the%20sample%20input.%20It%20shows%20the%20two%20possible%20binary%20search%20trees%2C%20the%20probabilities%20and%20the%20associated%20costs.%5Cn%5Cn%20%21%5B%5D%28https%3A%5C%2F%5C%2Fcdn.luogu.com.cn%5C%2Fupload%5C%2Fvjudge_pic%5C%2FSP1789%5C%2F14a2b14c9b8c27c150ce9c2887f84486eb5e60d6.png%29%22%2C%22inputFormat%22%3A%22%22%2C%22outputFormat%22%3A%22%22%2C%22samples%22%3A%5B%5D%2C%22hint%22%3A%22%22%2C%22provider%22%3A%7B%22uid%22%3A3%2C%22name%22%3A%22%5Cu6d1b%5Cu8c37%22%2C%22slogan%22%3A%22%22%2C%22badge%22%3A%22%22%2C%22isAdmin%22%3Atrue%2C%22color%22%3A%22Purple%22%2C%22ccfLevel%22%3A0%7D%2C%22canEdit%22%3Afalse%2C%22limits%22%3A%7B%22time%22%3A%5B649%5D%2C%22memory%22%3A%5B1536000%5D%7D%2C%22stdCode%22%3A%22%22%2C%22vjudge%22%3A%7B%22origin%22%3A%22SPOJ%22%2C%22link%22%3A%22%5C%2Fjump%5C%2Fspoj%5C%2F1789%22%2C%22id%22%3A%221789%22%7D%2C%22tags%22%3A%5B%5D%2C%22wantsTranslation%22%3Atrue%2C%22totalSubmit%22%3A1%2C%22totalAccepted%22%3A0%2C%22pid%22%3A%22SP1789%22%2C%22title%22%3A%22GREEDULM%20-%20Huffman%5Cu00b4s%20Greed%22%2C%22difficulty%22%3A0%2C%22type%22%3A%22SP%22%7D%2C%22contest%22%3Anull%2C%22discussions%22%3A%5B%7B%22id%22%3A64620%2C%22title%22%3A%22%5Cu7ffb%5Cu8bd1%22%2C%22forum%22%3A%7B%22id%22%3A13406%2C%22name%22%3A%22SP1789%20GREEDULM%20-%20Huffman%5Cu00b4s%20Greed%22%2C%22slug%22%3A%22SP1789%22%7D%7D%5D%2C%22bookmarked%22%3Afalse%2C%22vjudgeUsername%22%3Anull%2C%22recommendations%22%3A%5B%5D%2C%22lastLanguage%22%3A%22%22%2C%22lastCode%22%3A%22%22%7D%2C%22currentTitle%22%3A%22GREEDULM%20-%20Huffman%5Cu00b4s%20Greed%22%2C%22currentTheme%22%3Anull%7D"));window._feConfigVersion=1572920822;</script>
<script src="https://cdn.luogu.com.cn/fe/loader.js?ver=20191106" charset="utf-8" defer></script>
</head>
<body>
<div id="app">
<div class="lg-container">
<article>
<h1>GREEDULM - Huffman´s Greed</h1>
<h2>题目描述</h2>
<div> In the following we define the basic terminology of trees. A **tree** is defined inductively: It has a **root** which is either an **external node** (a leaf), or an **internal node** having a sequence of trees as its children. An internal node is also called the **parent** of the roots of its child trees. The **level** of a node in a tree is defined inductively: The root has level `0`, and the level of a node is `1` more than the level of its parent node.
Every internal node of a **binary tree** has precisely two children, its left sub-tree and its right sub-tree. Every internal node of a **labelled binary tree** is additionally marked with a string, its label. A **binary search tree** is a labelled binary tree where every internal node `t` satisfies the following condition: All labels of nodes in the left sub-tree of `t` are less than the label of `t` which is, in turn, less than all labels of nodes in the right sub-tree of `t`. For this condition, we assume lexicographic, i.e., alphabetic order on the strings.
An **inorder traversal** of a tree is defined recursively: A leaf is just visited, and for an internal node first its left sub-tree is traversed inorder, then the node itself is visited, finally its right sub-tree is traversed inorder. It follows that an inorder traversal of a binary search tree yields the labels in lexicographic order. Note that binary search trees whose shapes differ may nevertheless yield the same sequence of strings while being traversed inorder.
When a given string `s` is looked for in a binary search tree, we compare `s` to the label `l` of the root. We are done if `s=l`, otherwise if `s<l` we continue to search in the left sub-tree, and if `s>l` in the right sub-tree. If a leaf is reached, we know that `s` is not in the tree.
The number of comparisons performed in such a search procedure depends on `s` and the actual shape of the search tree. Therefore, there is an interest in constructing binary search trees that store a given sequence of strings but provide as efficient access as possible. Of course, we don't know in advance which strings will be looked up in the tree, so we need to make some assumptions.
Let `n` be the number of strings that are to be stored in the binary search tree. Let `K $ _{1} $ ,...,K $ _{n} $ ` be these strings in lexicographic order. Let `p $ _{1} $ ,...,p $ _{n} $ ` and `q $ _{0} $ ,...,q $ _{n} $ ` be `2n+1` non-negative real numbers such that `∑ $ _{i=1..n} $ p $ _{i} $ + ∑ $ _{i=0..n} $ q $ _{i} $ = 1`. The interpretation of these numbers is:
- `p $ _{i} $ ` = probability that the search argument `s` is `K $ _{i} $ `.
- `q $ _{i} $ ` = probability that `s` lies (lexicographically) strictly between `K $ _{i} $ ` and `K $ _{i+1} $ `.
By convention, `q $ _{0} $ ` is the probability that `s` is less than `K $ _{1} $ `, and `q $ _{n} $ ` is the probability that `s` is greater than `K $ _{n} $ `. We want to find a binary search tree containing nodes with labels `K $ _{1} $ ,...,K $ _{n} $ ` that minimises the expected number of comparisons in the search, namely
`cost = ∑ $ _{i=1..n} $ p $ _{i} $ *(1 + level of internal node K $ _{i} $ ) + ∑ $ _{i=0..n} $ q $ _{i} $ *(level of leaf between K $ _{i} $ and K $ _{i+1} $ )`. The leaf between `K $ _{i} $ ` and `K $ _{i+1} $ ` is that leaf reached in the search for a string `s` that lies (lexicographically) strictly between `K $ _{i} $ ` and `K $ _{i+1} $ `. Adhere to the convention stated above for the border cases.
The following figure illustrates the first test case of the sample input. It shows the two possible binary search trees, the probabilities and the associated costs.
![](https://cdn.luogu.com.cn/upload/vjudge_pic/SP1789/14a2b14c9b8c27c150ce9c2887f84486eb5e60d6.png)</div>
<h2>输入输出格式</h2>
<h3>输入格式</h3>
<br />
<div></div>
<h3>输出格式</h3>
<br />
<div></div>
<h2>输入输出样例</h2>
<i>暂无测试点</i>
</article>
</div>
</div>
</body>
</html>
