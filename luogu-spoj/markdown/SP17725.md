# BADXOR - Bad XOR

## 题目描述

**Bad XOR | BADXOR**

**Time Limit: 1s**

You are given an array A of N elements. Also you are given another array B of M elements. Any subset (i­ $ _{1} $ , i $ _{2} $ , i $ _{3} $ , …., i $ _{p} $ ) is bad IFF ( Ai $ _{1} $ ⊕ Ai $ _{2} $ ⊕ …. ⊕ Ai $ _{p} $ ) equals any value of B. ⊕ means Bitwise XOR, which can be found with ^ syntax in popular programming languages. Now your job is to find the number of good subsets. Empty Subset has XOR value of 0.

**Input**

The first line of input denotes the number of test cases T (1 <= T <= 20). The first line of each test case contains two integers N and M ( 0 <= N, M <= 1000). The next line contains N integers of the array A (0 <= A $ _{i} $ <=1000). The next line contains M integers of the array B (0 <= B $ _{i} $ <=1000). You can assume that each element of array B will be unique.

**Output**

For each case, print the case number and the total numbers of good subsets in a line. As the result can be very big, output it modulo 100000007.

**Sample Input**

**Output for Sample Input**

2

2 3

1 2

0 1 2

1 3

1

0 1 2

Case 1: 1

Case 2: 0

Problem Setter: Nafis Sadique

Special Thanks: Ahmad Faiyaz

## 输入输出格式

### 输入格式

### 输出格式

## 输入输出样例

暂无测试点

