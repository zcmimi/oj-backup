# Tree Summing

## 题意翻译

 题目描述

LISP是最早的高级程序设计语言中的一种，和FORTRAN一样，也是目前还在使用的最老的语言之一。LISP中使用的基本的数据结构是列表，可以用来表示其他重要的数据结构，比如树。

本问题判断由LISP的S-表达式表示的二叉树是否具有某项性质。

给出一棵整数的二叉树，请写一个程序判定是否存在这样一条从树根到树叶的路，路上的结点的总和等于一个特定的整数。例如，在下图所示的树中有4条从树根到树叶的路，这些路的总和是27, 22, 26和18。

在输入中二叉树以LISP的S-表达式表示，形式如下。

empty tree ::= ()

tree ::= empty tree (integer tree tree)

在上图给出的树用表达式表示为(5 (4 (11 (7 () ()) (2 () ()) ) ()) (8 (13 () ()) (4 () (1 () ()) ) ) )。

在这一公式中树的所有树叶表示形式为(整数 () () ) 。

因为空树（empty tree）没有从树根到树叶的路，对于在一棵空树中是否存在一条路总和等于特定的数的查询回答是负数。

输入

输入包含一系列的测试样例，每个测试用例形式为整数/树，由一个整数，后面跟一个或多个空格，然后是一个以上述的S-表达式形式表示二叉树。所有二叉树的S-表达式是有效的，但表达式可能占据几行，也可能包含若干空格。输入文件中有一个或多个测试用例，输入以文件结束符结束。

输出

对输入中每个测试用例（整数/树）输出一行。对每一个I,T (I是整数，T是树)，如果在T中存在从根到叶的总和是I的路，则输出字符串yes；如果没有从根到叶的总和是I的路，则输出字符串no。

样例输入

22 (5(4(11(7()())(2()()))()) (8(13()())(4()(1()()))))

20 (5(4(11(7()())(2()()))()) (8(13()())(4()(1()()))))

10 (3

(2 (4 () () )

(8 () () ) )

(1 (6 () () )

(4 () () ) ) )

5 ()

样例输出

yes

no

yes

no

## 题目描述

[problemUrl]: https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=3&page=show_problem&problem=48

[PDF](https://uva.onlinejudge.org/external/1/p112.pdf)

![](https://cdn.luogu.com.cn/upload/vjudge_pic/UVA112/ee9b47e479d70c22d369ddb505af41da0aebc120.png)

## 输入输出格式

### 输入格式

![](https://cdn.luogu.com.cn/upload/vjudge_pic/UVA112/ed3ab11220fdaedeaca0d5d0762506623d0211e6.png)

### 输出格式

![](https://cdn.luogu.com.cn/upload/vjudge_pic/UVA112/7bc6b3b19fdaeb2394c8263c567feae640a649bc.png)

## 输入输出样例

### 输入样例 #1

```cpp
22 (5(4(11(7()())(2()()))()) (8(13()())(4()(1()()))))
20 (5(4(11(7()())(2()()))()) (8(13()())(4()(1()()))))
10 (3
(2 (4 () () )
(8 () () ) )
(1 (6 () () )
(4 () () ) ) )
5 ()
```


### 输出样例 #1

```cpp
yes
no
yes
no
```


